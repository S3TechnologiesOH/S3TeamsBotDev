"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULTS = void 0;
const axios_1 = __importDefault(require("axios"));
const BaseAPI_1 = require("./BaseAPI");
const CW_AUTOMATE_DEBUG = !!process.env.CW_AUTOMATE_DEBUG;
exports.DEFAULTS = {
    entryPoint: 'cwa',
    retryOptions: {
        retries: 4,
        minTimeout: 50,
        maxTimeout: 20000,
        randomize: true,
    },
    logger: (debug = false) => (level, text, meta) => {
        switch (level) {
            case 'error':
                console.error(`${level}: ${text}`, meta);
                return;
            case 'warn':
                if (debug) {
                    console.log(`${level}: ${text}`, meta);
                }
                return;
            case 'info': {
                if (debug) {
                    console.info(`${level}: ${text}`, meta);
                }
                return;
            }
            default:
                console.log(`${level}: ${text}`, meta);
                return;
        }
    },
};
/**
 * @internal
 */
class Automate {
    constructor({ serverUrl, username, password, twoFactorPasscode, token, clientId, timeout = 20000, retry = false, retryOptions = exports.DEFAULTS.retryOptions, logger, debug, }) {
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "instance", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * @public
         */
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * @public
         * Pass the function to be paginated first, then arguments to paginate itself,
         * then any additional arguments to the function in order
         *
         * @example
         * ```javascript
         *  cwa.paginate(cwa.ComputersAPI.getComputerList, {startPage: 1, pageSize: 1000}, {conditions: 'inactiveFlag = false'})
         *
         * ```
         */
        Object.defineProperty(this, "paginate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (token && username && password) {
            throw new Error('Authenticate with token or username and password only, do not pass both methods');
        }
        if (!token && !username && !password) {
            throw new Error('Missing options [token] or [username, password]');
        }
        if (!clientId) {
            throw new Error('Missing option [clientId]');
        }
        this.config = {
            serverUrl,
            username,
            password,
            twoFactorPasscode,
            clientId,
            timeout,
            retry,
            retryOptions: { ...exports.DEFAULTS.retryOptions, ...retryOptions },
            logger: logger ? logger : exports.DEFAULTS.logger(debug || CW_AUTOMATE_DEBUG),
            debug: debug || CW_AUTOMATE_DEBUG,
        };
        this.instance = axios_1.default.create();
        if (token) {
            this.config.token = token;
            this.createAxiosInstance();
        }
        this.request = (0, BaseAPI_1.makeRequest)({ config: this.config, api: this.api, thisObj: this });
        this.paginate = (0, BaseAPI_1.makePaginate)({ thisObj: this });
    }
    get token() {
        return this.config.token;
    }
    set token(token) {
        this.config.token = token;
    }
    static async getToken({ username, password, twoFactorPasscode, serverUrl, }) {
        const result = await axios_1.default.post(`https://${serverUrl}/${exports.DEFAULTS.entryPoint}/api/v1/apitoken`, {
            username,
            password,
            twoFactorPasscode,
        });
        return result.data;
    }
    async verifyToken() {
        try {
            const result = await this.api({ path: '/api/v1/FeatureFlags', method: 'get' });
            return true;
        }
        catch (err) {
            return false;
        }
    }
    /**
     * @internal
     */
    async api({ path, method, params, data, }) {
        var _a, _b;
        const { username, password, serverUrl, twoFactorPasscode } = this.config;
        if (!this.config.token || !this.instance) {
            const result = await Automate.getToken({ username, password, serverUrl, twoFactorPasscode });
            this.config.token = result.AccessToken;
            this.createAxiosInstance();
        }
        try {
            const result = await this.instance({
                url: path,
                method,
                params,
                data,
            });
            return result === null || result === void 0 ? void 0 : result.data;
        }
        catch (error) {
            if (error.isAxiosError) {
                throw {
                    status: (_a = error.response) === null || _a === void 0 ? void 0 : _a.status,
                    data: (_b = error.response) === null || _b === void 0 ? void 0 : _b.data,
                    message: error === null || error === void 0 ? void 0 : error.message,
                };
            }
            // something else catastrophic went wrong
            throw error;
        }
    }
    createAxiosInstance() {
        const { serverUrl, timeout, clientId } = this.config;
        this.instance = axios_1.default.create({
            timeout,
            baseURL: `https://${serverUrl}/${exports.DEFAULTS.entryPoint}`,
            headers: {
                Accept: `application/json`,
                'Cache-Control': 'no-cache',
                Authorization: `Bearer ${this.config.token}`,
                clientId,
            },
        });
    }
}
exports.default = Automate;
//# sourceMappingURL=Automate.js.map