"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePaginate = exports.makeRequest = void 0;
const promise_retry_1 = __importDefault(require("promise-retry"));
/**
 * curried request function
 * @internal
 */
const makeRequest = ({ config, api, thisObj, }) => ({ path, method = 'get', params, data }) => {
    const retryCodes = ['ECONNRESET', 'ETIMEDOUT', 'ESOCKETTIMEDOUT'];
    const boundApi = api.bind(thisObj);
    if (!path) {
        throw new Error('path must be defined.');
    }
    let startTime = Date.now();
    const { retry, retryOptions, logger } = config;
    if (!retry) {
        return boundApi({ path, method, params, data })
            .then((result) => {
            logger('info', `${method} ${path} ${Date.now() - startTime}ms params=${JSON.stringify(params)}`);
            return result;
        })
            .catch((error) => {
            logger('error', `${method} ${path} ${Date.now() - startTime}ms params=${JSON.stringify(params)}`, error);
            throw error;
        });
    }
    else {
        return (0, promise_retry_1.default)(retryOptions, (retry, number) => {
            return boundApi({ path, method, params, data }).catch((error) => {
                logger('warn', `${method} ${path} ${Date.now() - startTime}ms error occurred: ${error.code}, retry=${number}, params=${JSON.stringify(params)}`);
                startTime = Date.now();
                if (retryCodes.includes(error.code)) {
                    return retry(error);
                }
                throw error;
            });
        })
            .then((result) => {
            logger('info', `${method} ${path} ${Date.now() - startTime}ms params=${JSON.stringify(params)}`);
            return result;
        })
            .catch((error) => {
            logger('error', `${method} ${path} ${Date.now() - startTime}ms error occurred: ${error.code}, params=${JSON.stringify(params)}`, error);
            throw error;
        });
    }
};
exports.makeRequest = makeRequest;
/**
 * curried paginate function
 * @internal
 */
const makePaginate = ({ thisObj }) => (apiMethod, paginateArgs = {}, ...methodArgs) => {
    const { startPage = 1, pageSize = 1000 } = paginateArgs;
    return new Promise(async (resolve, reject) => {
        let results = [];
        let page = startPage;
        if (startPage === undefined || startPage < 1) {
            page = 1;
        }
        while (true) {
            try {
                const pageResults = await getPage(apiMethod, methodArgs, thisObj, page++, pageSize);
                // complete page returned, loop again
                if (Array.isArray(pageResults) && pageResults.length > 0) {
                    results = [...results, ...pageResults];
                    if (pageResults.length !== pageSize) {
                        // incomplete page, there are no more pages
                        break;
                    }
                }
                else {
                    // no results returned, this is the last page, previous page was full
                    break;
                }
            }
            catch (error) {
                return reject(error);
            }
        }
        return resolve(results);
    });
};
exports.makePaginate = makePaginate;
/**
 * @internal
 */
function getPage(apiMethod, methodArgs, thisObj, page = 1, pageSize = 1000) {
    // Javascript Function.length returns number of non-default values
    // the method args will always be greater than the api method args
    // due to this, if params is not passed in, even as an empty object,
    // we need to throw an error
    if (methodArgs.length < apiMethod.length) {
        throw new Error(`CommonParams must be passed in for pagination to work properly for function ${apiMethod.name}`);
    }
    // look for CommonParams and inject page and pageSize
    // check for apiMethod function args length
    // get last arg
    const commonParams = methodArgs.pop();
    commonParams.page = page;
    commonParams.pageSize = pageSize;
    methodArgs.push(commonParams);
    return apiMethod.apply(thisObj, methodArgs);
}
/**
 * @internal
 */
function isCommonParametersLike(input) {
    if (typeof input === 'object' && input !== null) {
        return true;
    }
    else {
        return false;
    }
}
//# sourceMappingURL=BaseAPI.js.map